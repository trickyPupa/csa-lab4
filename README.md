# csa-lab4

вариант: forth | stack | neum | mc | tick | binary | stream | port | pstr | prob2 | pipeline

- `lisp` -- синтаксис языка Lisp. S-exp.
    - Требуется поддержка рекурсивных функций.
    - Необходимо объяснить, как происходит отображение сложных выражений на регистры и память.
    - Любое выражение (statement) -- expression, что должно быть продемонстрировано в тестах. Примеры корректного кода (с точностью до ключевых слов):
        - `(print (if (= 1 x) "T" "F"))`
        - `(setq x (if (= 1 x) 2 3))`
        - `(setq x (loop ...))`
        - `(print (setq x 13))`

Примечание. Язык надо реализовывать по принципам:

- минимальной реализации;
- минимального удивления;
- с оглядкой на референсные реализации (особенно это касается языка Lisp).

К примеру (ваш вариант `lisp`):

- (хорошо) Вам нужен цикл `for` и не нужен цикл `while`. Варианты:
    - Вы реализуете цикл через конструкцию `loop` (см. Common Lisp) и поддерживаете только `for`.
    - Вы реализуете синтаксис `loop - recur` (см. Clojure).
    - Вы реализуете рекурсивные вызовы с пониманием, как это работает и оптимизируется. Блистаете оптимизацией хвостовой рекурсии.
    - Иные варианты.
- (хорошо) Традиционно языки семейства `lisp` поддерживают переменное кол-во аргументов `(+ 1 2 3)`, вы пишете в коде `(+ 1 (+ 2 3))`.
- (плохо) У вас есть код: `(setq a (if (= x 0) 1 2))`.
    - В качестве предиката в вашем коде используются только выражения, транслятор не позволяет сделать вызов для переменной: `(setq a (if p 1 2))`.

### Архитектура

- `stack` -- система команд должна быть стековой:
    - Вместо регистров используется стек.
    - Это не исключает и не заменяет наличие памяти команд и памяти данных.

### Архитектура организации памяти

Тип памяти -- однопортовая.

- `neum` -- фон Неймановская архитектура.

### Control Unit

- `mc` -- microcoded.
    - В отчёте необходимо задокументировать уровень микроинструкций.
    - Моделирование должно выполняться с точностью до такта.
    - Микрокод должен быть сохранён в отдельной памяти для микропрограмм.
    - Модель процессора должна исполнять микрокод.

### Точность модели

- `tick` -- процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

### Представление машинного кода

- `binary` -- бинарное представление.
    - Требуются настоящие бинарные файлы, а не текстовые файлы с `0` и `1`.
    - Требуется отладочный вывод в текстовый файл вида:

        ```text
        <address> - <HEXCODE> - <mnemonic>
        20 - 03340301 - add #01 <- 34 + #03
        ```

### Ввод-вывод

- `stream`

Ввод-вывод осуществляется как поток токенов. Есть в примере. Логика работы:

- При старте модели у вас есть буфер, в котором представлены все данные ввода (`['h', 'e', 'l', 'l', 'o']`).
- При обращении к вводу (выполнение инструкции) модель процессора получает "токен" (символ) информации.
- Если данные в буфере кончились -- останавливайте моделирование.
- Вывод данных реализуется аналогично, по выполнении команд в буфер вывода добавляется ещё один символ.
- По окончании моделирования показать все выведенные данные.
- Логика работы с буфером реализуется в рамках модели на Python.

### Ввод-вывод ISA

Поддержка ввода-вывода с точки зрения системы команд.

- `port` -- port-mapped (специальные инструкции для ввода-вывода)
    - адресация портов ввода-вывода должна присутствовать.

### Поддержка строк

Варианты:

- `pstr` -- Length-prefixed (Pascal string)

Общие требования:

- Статические строки должны храниться в памяти (секции) данных.
- Один символ может храниться в одном машинном слове (несмотря на явную неэффективность).
- Работа со строками реализуется процедурами или функциями на разработанном вами языке.

### Алгоритм

- Входные данные должны подаваться через ввод.
- Результат должен быть подан на вывод.
- Формат ввода/вывода данных -- на ваше усмотрение.

Алгортимы:

- `alg2` -- Euler problem 6 [link](https://projecteuler.net/problem=6)

### Усложнение

- `pipeline` -- конвейерная организация работы процессора.
    - Количество стадий конвейера -- не менее 3.
    - Необходимо показать влияние конвейера на производительность написанных программ.
    - В схеме необходимо явно отразить стадии работы конвейера. Пример -- см. в слайдах лекций.
